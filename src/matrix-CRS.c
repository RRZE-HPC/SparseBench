/* Copyright (C) NHR@FAU, University Erlangen-Nuremberg.
 * All rights reserved. This file is part of CG-Bench.
 * Use of this source code is governed by a MIT style
 * license that can be found in the LICENSE file. */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "allocate.h"
#include "matrix.h"

void convertMatrix(Matrix* sm, GMatrix* m)
{
  sm->startRow = m->startRow;
  sm->stopRow  = m->stopRow;
  sm->totalNr  = m->totalNr;
  sm->totalNnz = m->totalNnz;
  sm->nr       = m->nr;
  sm->nc       = m->nc;
  sm->nnz      = m->nnz;

  sm->rowPtr = (CG_UINT*)allocate(ARRAY_ALIGNMENT,
      (m->nr + 1) * sizeof(CG_UINT));
  sm->colInd = (CG_UINT*)allocate(ARRAY_ALIGNMENT, m->nnz * sizeof(CG_UINT));
  sm->val    = (CG_FLOAT*)allocate(ARRAY_ALIGNMENT, m->nnz * sizeof(CG_FLOAT));

  Entry* entries = m->entries;

  CG_UINT numRows = m->nr;
  CG_UINT* rowPtr = m->rowPtr;

  // convert to CRS format
  for (int rowID = 0; rowID < numRows; rowID++) {
    sm->rowPtr[rowID] = m->rowPtr[rowID];

    // loop over all elements in Row
    for (int id = m->rowPtr[rowID]; id < m->rowPtr[rowID + 1]; id++) {
      sm->val[id]    = (CG_FLOAT)entries[id].val;
      sm->colInd[id] = (CG_UINT)entries[id].col;
    }
  }

  sm->rowPtr[numRows] = m->rowPtr[numRows];
}

void spMVM(Matrix* m, const CG_FLOAT* restrict x, CG_FLOAT* restrict y)
{
  CG_UINT* colInd = m->colInd;
  CG_FLOAT* val   = m->val;

  CG_UINT numRows = m->nr;
  CG_UINT* rowPtr = m->rowPtr;

#pragma omp parallel for schedule(OMP_SCHEDULE)
  for (int i = 0; i < numRows; i++) {
    CG_FLOAT sum = 0.0;

    // loop over all elements in row
    for (int j = rowPtr[i]; j < rowPtr[i + 1]; j++) {
      sum += val[j] * x[colInd[j]];
    }

    y[i] = sum;
  }
}
